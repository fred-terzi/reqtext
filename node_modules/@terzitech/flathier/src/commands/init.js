/**
 * Initializes the project by creating necessary files and directories.
 * @module init
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import generateUniqueId from '../utils/generateUniqueId.js';
import sanitizeSpaces from '../utils/sanitizeSpaces.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Finds the root directory of the project by locating the nearest package.json file.
 * Starts from process.cwd() so that “root” is always where the user invoked the command.
 * @param {string} [start=process.cwd()] - The directory to start searching from.
 * @returns {Promise<string>} The root directory path.
 * @throws Will throw an error if package.json is not found.
 */
async function findProjectRoot(start = process.cwd()) {
  let dir = start;
  while (true) {
    const maybePkg = path.join(dir, 'package.json');
    try {
      await fs.access(maybePkg);
      return dir;
    } catch {
      const parent = path.dirname(dir);
      if (parent === dir) {
        throw new Error('package.json not found');
      }
      dir = parent;
    }
  }
}

/**
 * Initializes the project by creating necessary directories and files.
 * @param {string} fileName - The base name for the main FHR file.
 * @param {string} customExt - The custom extension for the template files.
 * @returns {Promise<void>}
 */
export default async function init(fileName = 'FlatHierFormat', customExt = '.fhr', customID = 'id') {
  // Root will now be the cwd where the user ran `npx fhr init`
  const root = await findProjectRoot();

  // Sanitize the file name to replace spaces with underscores
  fileName = sanitizeSpaces(fileName);

  // Paths relative to project root
  const extNoDot = customExt.startsWith('.') ? customExt.slice(1) : customExt;
  const extWithJson = `${extNoDot}.json`;
  const folderPath      = path.join(root, `.${extNoDot}`);
  const destinationPath = path.join(folderPath, `template.${extWithJson}`);
  const mainFileName    = fileName.endsWith(`.${extWithJson}`)
    ? fileName
    : `${fileName}.${extWithJson}`;
  const mainFilePath    = path.join(root, mainFileName);

  // Check if the main project file already exists
  try {
    await fs.access(mainFilePath);
    console.error(`❌ Project file already exists at: ${mainFilePath}`);
    return; // Abort initialization
  } catch {
    // File does not exist, continue with initialization
  }

  // Path to the built-in template inside this package
  const templatePath = path.join(__dirname, '../fhrTemplates/fhrTemplate.json');

  // Path to the built-in config template inside this package
  const configTemplatePath = path.join(__dirname, '../fhrTemplates/fhrConfigTemplate.json');
  const configDestinationPath = path.join(folderPath, `config.${extWithJson}`);

  // Path to the custom extension store
  const customExtStorePath = path.join(__dirname, '../fhrTemplates/customExtStore.json');
  let customExtStore = {};
  try {
    const storeData = await fs.readFile(customExtStorePath, 'utf-8');
    customExtStore = JSON.parse(storeData);
  } catch {
    // File might not exist or be empty; start with empty object
  }
  customExtStore.customExt = customExt;
  try {
    await fs.writeFile(customExtStorePath, JSON.stringify(customExtStore, null, 2));
    console.log(`✅ Stored customExt (${customExt}) in customExtStore.json`);
  } catch (err) {
    console.error('❌ Could not update customExtStore.json:', err);
  }

  // Save the filepath into the filepath variable in config
  

  console.log(`✅ Creating folder at: ${path.relative(process.cwd(), folderPath)}`);
  await fs.mkdir(folderPath, { recursive: true });



  try {
    // Read and parse the base template from flathier's own templates directory
    const rawTemplateData = await fs.readFile(templatePath, 'utf-8');
    const templateArray   = JSON.parse(rawTemplateData);

    if (!Array.isArray(templateArray)) {
      throw new Error('❌ Template data is not a flat array of objects');
    }

    // Save clean template with updated title only
    const cleanedTemplate = templateArray.map((item, index) => {
      const newItem = { ...item };
      newItem.title = index === 0 ? fileName : item.title;
      // Replace unique_id with customID_ID and set to PLACEHOLDER if needed
      if (customID !== 'unique_id') {
        delete newItem.unique_id;
        const customIDText = `${customID}_ID`;
        newItem[customIDText] = 'PLACEHOLDER';
      } else {
        newItem.unique_id = 'PLACEHOLDER';
      }
      return newItem;
    });
    await fs.writeFile(destinationPath, JSON.stringify(cleanedTemplate, null, 2));
    console.log(`✅ Wrote clean template to: ${path.relative(process.cwd(), destinationPath)}`);

    // Copy the config template into the new folder
    await fs.copyFile(configTemplatePath, configDestinationPath);
    console.log(`✅ Copied config template to: ${path.relative(process.cwd(), configDestinationPath)}`);

    // Read, update, and write the config file
    const configData = await fs.readFile(configDestinationPath, 'utf-8');
    const configJson = JSON.parse(configData);
    configJson.filepath = `./${mainFileName}`; // or adjust path as needed
    await fs.writeFile(configDestinationPath, JSON.stringify(configJson, null, 2));
    console.log(`✅ Updated config file with new filepath: ${configJson.filepath}`);

    // Create working copy with unique IDs
    const workingCopy = cleanedTemplate.map(item => {
      const newItem = { ...item };
      // If customID is not 'unqiue_id', replace unique_id with customID
      if (customID !== 'unqiue_id') {
        delete newItem.unique_id;
        const customIDText = `${customID}_ID`;
        newItem[customIDText] = generateUniqueId();
      } else {
        newItem.unique_id = generateUniqueId();
      }
      return newItem;
    });
    await fs.writeFile(mainFilePath, JSON.stringify(workingCopy, null, 2));
    console.log(`✅ Created working file at: ${path.relative(process.cwd(), mainFilePath)}`);

  } catch (error) {
    console.error('❌ Error during initialization:', error);
  }

  console.log('✅ Initialization complete.');
}
